use crate::error::{HostError, Result};
use crate::proof::Proof;
use crate::receipt::Receipt;
use execution_utils::unrolled::UnrolledProgramProof;
use std::path::{Path, PathBuf};

mod cpu_prover;
mod dev_prover;
mod gpu_prover;

pub use self::cpu_prover::{CpuProver, CpuProverBuilder};
pub use self::dev_prover::{DevProver, DevProverBuilder};
pub use self::gpu_prover::{GpuProver, GpuProverBuilder};

pub(super) const DEFAULT_RAM_BOUND_BYTES: usize = 1 << 30;
pub(super) const DEFAULT_CPU_CYCLE_BOUND: usize = u32::MAX as usize;

/// Host prover interface.
pub trait Prover {
    fn prove(&self, input_words: &[u32]) -> Result<ProveResult>;
}

/// Maximum proof layer generated by the prover.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Default, serde::Serialize, serde::Deserialize)]
pub enum ProverLevel {
    Base,
    RecursionUnrolled,
    #[default]
    RecursionUnified,
}

impl ProverLevel {
    #[cfg(feature = "gpu-prover")]
    pub fn as_unrolled_level(self) -> execution_utils::unrolled_gpu::UnrolledProverLevel {
        match self {
            ProverLevel::Base => execution_utils::unrolled_gpu::UnrolledProverLevel::Base,
            ProverLevel::RecursionUnrolled => {
                execution_utils::unrolled_gpu::UnrolledProverLevel::RecursionUnrolled
            }
            ProverLevel::RecursionUnified => {
                execution_utils::unrolled_gpu::UnrolledProverLevel::RecursionUnified
            }
        }
    }
}

/// Proof and receipt produced by `prove`.
#[derive(Clone, Debug)]
pub struct ProveResult {
    pub proof: Proof,
    pub cycles: u64,
    pub receipt: Receipt,
}

pub(super) fn resolve_app_bin_path(path: &Path) -> Result<PathBuf> {
    let base_path = base_path(path)?;
    let app_bin_path = PathBuf::from(format!("{base_path}.bin"));

    if !app_bin_path.exists() {
        return Err(HostError::Prover(format!(
            "binary not found: {}",
            app_bin_path.display()
        )));
    }

    app_bin_path.canonicalize().map_err(|err| {
        HostError::Prover(format!(
            "failed to canonicalize binary path {}: {err}",
            app_bin_path.display()
        ))
    })
}

pub(super) fn resolve_text_path(app_bin_path: &Path) -> Result<PathBuf> {
    let mut app_text_path = app_bin_path.to_path_buf();
    app_text_path.set_extension("text");

    if !app_text_path.exists() {
        return Err(HostError::Prover(format!(
            "text file not found: {}",
            app_text_path.display()
        )));
    }

    app_text_path.canonicalize().map_err(|err| {
        HostError::Prover(format!(
            "failed to canonicalize text path {}: {err}",
            app_text_path.display()
        ))
    })
}

pub(super) fn base_path(app_bin_path: &Path) -> Result<String> {
    let path_str = app_bin_path
        .to_str()
        .ok_or_else(|| HostError::Prover("app path is not valid UTF-8".to_string()))?;
    if let Some(stripped) = path_str.strip_suffix(".bin") {
        Ok(stripped.to_string())
    } else {
        Ok(path_str.to_string())
    }
}

pub(super) fn resolve_worker_threads(worker_threads: Option<usize>) -> usize {
    worker_threads
        .or_else(|| {
            std::thread::available_parallelism()
                .ok()
                .map(|count| count.get())
        })
        .unwrap_or(1)
}

pub(super) fn receipt_from_real_proof(proof: &UnrolledProgramProof) -> Receipt {
    let mut registers = [0u32; 32];
    for (idx, reg) in proof
        .register_final_values
        .iter()
        .take(registers.len())
        .enumerate()
    {
        registers[idx] = reg.value;
    }
    Receipt::from_registers(registers)
}
